<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Graph creation · ShadowGraphs.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://SuperGrobi.github.io/ShadowGraphs.jl/BuildGraph/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ShadowGraphs.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Graph creation</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#API"><span>API</span></a></li></ul></li><li><a class="tocitem" href="../Persistence/">IO</a></li><li><a class="tocitem" href="../Plotting/">Plotting</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Graph creation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Graph creation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SuperGrobi/ShadowGraphs.jl/blob/main/docs/src/BuildGraph.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Building-Graphs"><a class="docs-heading-anchor" href="#Building-Graphs">Building Graphs</a><a id="Building-Graphs-1"></a><a class="docs-heading-anchor-permalink" href="#Building-Graphs" title="Permalink"></a></h1><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>We use <code>LightOSM.jl</code> as a basis to handle all the downloading, saving and importing of OSM data. Therefore, we expose very functions very similar to the ones in <code>LightOSM.jl</code>.</p><p>Then, the resulting <code>LightOSM.OSMGraph</code> instance is parsed into a <code>MetaDiGraph</code>, which is preserves the topology of the original street network, while reducing the number of nodes as much as possible. The geometry and various other parameters are attached to the <code>props</code> of every edge and vertex.</p><p>Even though we only expose a few functions for ease of use, we show all functions here, since it is very important to get an idea of what exactly this code is doing to your graph, before you start using it in any scientific capacity.</p><h2 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h2><ul><li><a href="#ShadowGraphs.add_edge_with_data!-Tuple{Any, Any, Any}"><code>ShadowGraphs.add_edge_with_data!</code></a></li><li><a href="#ShadowGraphs.geolinestring-Tuple{Any, Any}"><code>ShadowGraphs.geolinestring</code></a></li><li><a href="#ShadowGraphs.get_neighbor_osm_ids-Tuple{LightOSM.Way, Any, Any}"><code>ShadowGraphs.get_neighbor_osm_ids</code></a></li><li><a href="#ShadowGraphs.get_node_list-NTuple{4, Any}"><code>ShadowGraphs.get_node_list</code></a></li><li><a href="#ShadowGraphs.get_rotational_direction-Tuple{Any}"><code>ShadowGraphs.get_rotational_direction</code></a></li><li><a href="#ShadowGraphs.is_circular_way-Tuple{LightOSM.Way}"><code>ShadowGraphs.is_circular_way</code></a></li><li><a href="#ShadowGraphs.is_end_node-Tuple{Any, Any}"><code>ShadowGraphs.is_end_node</code></a></li><li><a href="#ShadowGraphs.is_lolipop_node-Tuple{Any, Any}"><code>ShadowGraphs.is_lolipop_node</code></a></li><li><a href="#ShadowGraphs.nodelist_between-NTuple{4, Any}"><code>ShadowGraphs.nodelist_between</code></a></li><li><a href="#ShadowGraphs.offset_point_between-Tuple{Any, Any, Any}"><code>ShadowGraphs.offset_point_between</code></a></li><li><a href="#ShadowGraphs.parse_lanes-Tuple{AbstractDict, Any}"><code>ShadowGraphs.parse_lanes</code></a></li><li><a href="#ShadowGraphs.parse_raw_ways-Tuple{Any, Any}"><code>ShadowGraphs.parse_raw_ways</code></a></li><li><a href="#ShadowGraphs.point_on_radius-Tuple{Any, Any, Any}"><code>ShadowGraphs.point_on_radius</code></a></li><li><a href="#ShadowGraphs.shadow_graph_from_download-Tuple{Symbol}"><code>ShadowGraphs.shadow_graph_from_download</code></a></li><li><a href="#ShadowGraphs.shadow_graph_from_file-Tuple{String}"><code>ShadowGraphs.shadow_graph_from_file</code></a></li><li><a href="#ShadowGraphs.shadow_graph_from_light_osm_graph-Tuple{Any}"><code>ShadowGraphs.shadow_graph_from_light_osm_graph</code></a></li><li><a href="#ShadowGraphs.shadow_graph_from_object-Tuple{Union{LightXML.XMLDocument, Dict}}"><code>ShadowGraphs.shadow_graph_from_object</code></a></li><li><a href="#ShadowGraphs.width-Tuple{Any}"><code>ShadowGraphs.width</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="ShadowGraphs.add_edge_with_data!-Tuple{Any, Any, Any}" href="#ShadowGraphs.add_edge_with_data!-Tuple{Any, Any, Any}"><code>ShadowGraphs.add_edge_with_data!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_edge_with_data!(g, s, d; data=Dict())</code></pre><p>adds new edge from <code>s</code> to <code>d</code> to <code>g::MetaDiGraph</code>, and populates it with the <code>props</code> given in <code>data</code>.</p><p>Special care is given to self and multi edges:</p><ul><li>self edges: if <code>s==d</code>, actually two new vertices with <code>props</code> of <code>:lat</code>, <code>:lon</code>, <code>pointgeom</code> and <code>:helper=true</code> are added.</li></ul><p>these new vertices (<code>h1</code> and <code>h2</code>) are then connected to form a loop like: <code>s --he1--&gt; h1 --real_edge--&gt; h2 --he2--&gt; d</code>, where <code>he1</code> and <code>he2</code> are helper edges with only one <code>prop</code> of <code>:helper=true</code>. <code>real_edge</code> is carrying all the <code>props</code> defined in <code>data</code></p><ul><li>multi edges: if <code>Edge(s,d) ∈ Edges(g)</code>, we add one new helper vertex with <code>props</code> of <code>:lat</code>, <code>:lon</code>, <code>pointgeom</code> and <code>:helper=true</code>.</li></ul><p>We connect to the graph like this: <code>s --he--&gt; h --real_edge--&gt; d</code>, where <code>he</code> is a helper edge with only one <code>prop</code>, <code>:helper=true</code>. <code>real_edge</code> carries all the <code>props</code> specified in <code>data</code></p><p>This process is nessecary to preserve the street network topology, since <code>MetaDiGraph</code>s do not support multi edges (and therefore also no multi self edges).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/ShadowGraphs.jl/blob/5abee85382844bf0cc63d74f523b918eecb5e834/src/BuildGraph.jl#L56-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ShadowGraphs.geolinestring-Tuple{Any, Any}" href="#ShadowGraphs.geolinestring-Tuple{Any, Any}"><code>ShadowGraphs.geolinestring</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">geolinestring(nodes, node_id_list)</code></pre><p>creates an <code>ArchGDAL linestring</code> from a dictionary mapping osm node ids to <code>LightOSM.Node</code> and a list of osm node ids, representing the nodes of the linestring in order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/ShadowGraphs.jl/blob/5abee85382844bf0cc63d74f523b918eecb5e834/src/BuildGraph.jl#L288-L293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ShadowGraphs.get_neighbor_osm_ids-Tuple{LightOSM.Way, Any, Any}" href="#ShadowGraphs.get_neighbor_osm_ids-Tuple{LightOSM.Way, Any, Any}"><code>ShadowGraphs.get_neighbor_osm_ids</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_neighbor_osm_ids(way::Way, start_id_index, nodes_in_nav_graph)</code></pre><p>gets the osm ids of directly connected nodes in the reduced (topological) graph along the <code>way</code>. The starting node from which the neighbour ids are to be calculated is assumed to be at index <code>start_id_index</code> in the array <code>nodes_in_nav_graph</code>.</p><p><strong>arguments</strong></p><ul><li>way: <code>Way</code> along which the neighbours are situated.</li><li>start<em>id</em>index: index of the start node in <code>nodes_in_nav_graph</code></li><li><code>nodes_in_nav_graph</code>: array with osm ids of the nodes which form the <code>way</code>, which are also topologically relevant.</li></ul><p><strong>returns</strong></p><p>tuple with:</p><ul><li>array of neighbouring osm ids</li><li>array of directions (either <code>+1</code> or -1`) that had to be taken from the start index to get to these neighbours</li></ul><p>(if you go &quot;along&quot; the <code>Way</code> or &quot;against&quot; it).</p><p><strong>notes</strong></p><p>While we check if all nodes in <code>nodes_in_nav_graph</code> are in the <code>way</code>, we do not check if the order is correct.</p><p>In addition, we expect the user to take care of the case where the start and end of the <code>way</code> are the same node and in the nav graph. You basically want to get rid of either the start or the end duplicate if they are in the nav graph. If you have  a <code>way</code>:</p><pre><code class="nohighlight hljs">ring1 = Way(1, [10,20,30,40,50,60,70,80, 10], Dict(&quot;oneway&quot;=&gt;false, &quot;reverseway&quot;=&gt;false, &quot;name&quot;=&gt;&quot;ring1&quot;))</code></pre><p>with the nodes <code>[10, 30, 60, 80]</code> in your nav graph, you need to pass only this list and not something like <code>10, 30, 60, 80, 10]</code>.</p><pre><code class="nohighlight hljs"># correct
get_neighbor_osm_ids(ring1, 1, [10, 30, 60, 80])  # ([80, 30], [-1, 1])
get_neighbor_osm_ids(ring1, 1, [30, 60, 80, 10])  # ([10, 60], [-1, 1])

# danger
get_neighbor_osm_ids(ring1, 1, [10, 30, 60, 80, 10])  # ([10, 30], [-1, 1])</code></pre><p>BUT! If you have a way like</p><pre><code class="nohighlight hljs">loli1 = Way(1, [10,20,30,40,50,60,70, 30], Dict(&quot;oneway&quot;=&gt;false, &quot;reverseway&quot;=&gt;false, &quot;name&quot;=&gt;&quot;loli1&quot;))</code></pre><p>you want to preserve the order and the duplicates. For example <code>[10, 30, 60, 30]</code>, or, depending on the topology, maybe also <code>[10, 30, 30]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/ShadowGraphs.jl/blob/5abee85382844bf0cc63d74f523b918eecb5e834/src/BuildGraph.jl#L118-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ShadowGraphs.get_node_list-NTuple{4, Any}" href="#ShadowGraphs.get_node_list-NTuple{4, Any}"><code>ShadowGraphs.get_node_list</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_node_list(way, start_pos, dest_osm_id, direction)</code></pre><p>returns a list of all osm node ids between the <code>start_pos</code> and the destination node given by <code>dest_osm_id</code>, with step direction of <code>direction</code>. If either end of the array is reached during the steps, periodic boundaries are used.</p><p><strong>arguments</strong></p><ul><li><code>way</code>: <code>Way</code> whose nodes should be used</li><li><code>start_pos</code> start index in <code>way.nodes</code> (NOT the osm_id of the start node)</li><li><code>dest_osm_id</code> osm id of the destination node</li><li><code>direction</code> direction in which the node list should be steped through in order to find the destination osm id.</li></ul><p><strong>returns</strong></p><p>array with osm ids, with start id and destination id at start and end.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/ShadowGraphs.jl/blob/5abee85382844bf0cc63d74f523b918eecb5e834/src/BuildGraph.jl#L211-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ShadowGraphs.get_rotational_direction-Tuple{Any}" href="#ShadowGraphs.get_rotational_direction-Tuple{Any}"><code>ShadowGraphs.get_rotational_direction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_rotational_direction(light_osm_graph)</code></pre><p>calculates the dominant rotational direction of circular ways in <code>light_osm_graph</code>. This can be used to infere the side of the road on which people in a street network drive.</p><p>returns <code>-1</code> if the rotation is lefthanded, <code>1</code> else. (prints warning if no clear direction could be established).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/ShadowGraphs.jl/blob/5abee85382844bf0cc63d74f523b918eecb5e834/src/BuildGraph.jl#L302-L309">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ShadowGraphs.is_circular_way-Tuple{LightOSM.Way}" href="#ShadowGraphs.is_circular_way-Tuple{LightOSM.Way}"><code>ShadowGraphs.is_circular_way</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_circular_way(way::Way)</code></pre><p>checks if a <code>LightOSM.Way</code> way starts at the same node it ends.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/ShadowGraphs.jl/blob/5abee85382844bf0cc63d74f523b918eecb5e834/src/BuildGraph.jl#L111-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ShadowGraphs.is_end_node-Tuple{Any, Any}" href="#ShadowGraphs.is_end_node-Tuple{Any, Any}"><code>ShadowGraphs.is_end_node</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_end_node(g, index)</code></pre><p>checks if node <code>index</code> in graph <code>g</code> represents the end of a street (that is, has as most one neighbour).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/ShadowGraphs.jl/blob/5abee85382844bf0cc63d74f523b918eecb5e834/src/BuildGraph.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ShadowGraphs.is_lolipop_node-Tuple{Any, Any}" href="#ShadowGraphs.is_lolipop_node-Tuple{Any, Any}"><code>ShadowGraphs.is_lolipop_node</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_lolipop_node(g, osm_id)</code></pre><p>checks if the node with <code>osm_id</code> is a &quot;lolipop node&quot; in the <code>LightOSM.OSMGraph</code> graph. A &quot;lolipop node&quot; is a node which occurs at the start/end of a way, as well as somewhere in the middle. (For example, the node <code>1</code> is considered a &quot;lolipop node&quot;&quot; in the following way: <code>1-2-3-4-5-1-6-7</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/ShadowGraphs.jl/blob/5abee85382844bf0cc63d74f523b918eecb5e834/src/BuildGraph.jl#L190-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ShadowGraphs.nodelist_between-NTuple{4, Any}" href="#ShadowGraphs.nodelist_between-NTuple{4, Any}"><code>ShadowGraphs.nodelist_between</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nodelist_between(way, start_osm_id, dest_osm_id, direction)</code></pre><p>builds the list of osm node ids in the way which are between the start and destination osm id (inclusively), by taking steps through the list of nodes in the direction of <code>direction</code>.</p><p>If the start osm id occurs twice in the way, the shorter list is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/ShadowGraphs.jl/blob/5abee85382844bf0cc63d74f523b918eecb5e834/src/BuildGraph.jl#L259-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ShadowGraphs.offset_point_between-Tuple{Any, Any, Any}" href="#ShadowGraphs.offset_point_between-Tuple{Any, Any, Any}"><code>ShadowGraphs.offset_point_between</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">offset_point_between(g, s, d)</code></pre><p>returns <code>x</code> and <code>y</code> coordinates of a point between nodes <code>s</code> and <code>d</code> in graph <code>g</code>, using the <code>:lon</code> and <code>:lat</code> properties of the nodes. the point is (approximately) centered between <code>s</code> and <code>p</code>, and offset from the centerline by a random distance.  (Use this function only to generate visually offset point, whose location is not relevant for anything except plotting).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/ShadowGraphs.jl/blob/5abee85382844bf0cc63d74f523b918eecb5e834/src/BuildGraph.jl#L34-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ShadowGraphs.parse_lanes-Tuple{AbstractDict, Any}" href="#ShadowGraphs.parse_lanes-Tuple{AbstractDict, Any}"><code>ShadowGraphs.parse_lanes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parse_lanes(tags::AbstractDict, tagname)</code></pre><p>parses the value of the key <code>tagname</code> in <code>tags</code>, assuming it to be a numerical value describing a certain number of lanes. Returns the parsed number of lanes if the tag exists or <code>missing</code> if not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/ShadowGraphs.jl/blob/5abee85382844bf0cc63d74f523b918eecb5e834/src/BuildGraph.jl#L368-L373">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ShadowGraphs.parse_raw_ways-Tuple{Any, Any}" href="#ShadowGraphs.parse_raw_ways-Tuple{Any, Any}"><code>ShadowGraphs.parse_raw_ways</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parse_raw_ways(raw_ways, network_type)</code></pre><p>parses a list of dicts describing OSM Ways into <code>LightOSM.Way</code> instances. This function is a slightly modified version of the one used in <code>LightOSM</code> (<code>parse_osm_network_dict</code>), to be able to use our own, non-dafault value assuming parsers for the labels.</p><p><strong>returns</strong></p><p>a dictionary mapping <code>osm_id</code> to <code>LightOSM.Way</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/ShadowGraphs.jl/blob/5abee85382844bf0cc63d74f523b918eecb5e834/src/BuildGraph.jl#L395-L404">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ShadowGraphs.point_on_radius-Tuple{Any, Any, Any}" href="#ShadowGraphs.point_on_radius-Tuple{Any, Any, Any}"><code>ShadowGraphs.point_on_radius</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point_on_radius(x, y, r)</code></pre><p>returns <code>x</code> and <code>y</code> coordinates of two random points on a circle with radius <code>r</code> around a point given by <code>x</code> and <code>y</code>. The two points have a fixed angluar offset of π/3 around the center. (This function assumes kartesian coordinates and euclidean distances. It is used to gernerate locations of helper nodes).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/ShadowGraphs.jl/blob/5abee85382844bf0cc63d74f523b918eecb5e834/src/BuildGraph.jl#L20-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ShadowGraphs.shadow_graph_from_download-Tuple{Symbol}" href="#ShadowGraphs.shadow_graph_from_download-Tuple{Symbol}"><code>ShadowGraphs.shadow_graph_from_download</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function shadow_graph_from_download(download_method::Symbol;
                                    network_type::Symbol=:drive,
                                    metadata::Bool=false,
                                    download_format::Symbol=:json,
                                    save_to_file_location::Union{String,Nothing}=nothing,
                                    download_kwargs...)</code></pre><p>downloads and builds the shadow graph from OSM.</p><p><strong>arguments</strong></p><ul><li><code>download_method::Symbol</code>: Download method, choose from <code>:place_name</code>, <code>:bbox</code> or <code>:point</code>.</li><li><code>network_type::Symbol=:drive</code>: Network type filter, pick from <code>:drive</code>, <code>:drive_service</code>, <code>:walk</code>, <code>:bike</code>, <code>:all</code>, <code>:all_private</code>, <code>:none</code>, <code>:rail</code></li><li><code>metadata::Bool=false</code>: Set true to return metadata.</li><li><code>download_format::Symbol=:json</code>: Download format, either <code>:osm</code>, <code>:xml</code> or <code>json</code>.</li><li><code>save_to_file_location::Union{String,Nothing}=nothing</code>: Specify a file location to save downloaded data to disk.</li></ul><p><strong>Required Kwargs for each Download Method</strong></p><p><em><code>download_method=:place_name</code></em></p><ul><li><code>place_name::String</code>: Any place name string used as a search argument to the Nominatim API.</li></ul><p><em><code>download_method=:bbox</code></em></p><ul><li><code>minlat::AbstractFloat</code>: Bottom left bounding box latitude coordinate.</li><li><code>minlon::AbstractFloat</code>: Bottom left bounding box longitude coordinate.</li><li><code>maxlat::AbstractFloat</code>: Top right bounding box latitude coordinate.</li><li><code>maxlon::AbstractFloat</code>: Top right bounding box longitude coordinate.</li></ul><p><em><code>download_method=:point</code></em></p><ul><li><code>point::GeoLocation</code>: Centroid point to draw the bounding box around.</li><li><code>radius::Number</code>: Distance (km) from centroid point to each bounding box corner.</li></ul><p><em><code>download_method=:polygon</code></em></p><ul><li><code>polygon::AbstractVector</code>: Vector of longitude-latitude pairs.</li></ul><p><strong>Network Types</strong></p><ul><li><code>:drive</code>: Motorways excluding private and service ways.</li><li><code>:drive_service</code>: Motorways including private and service ways.</li><li><code>:walk</code>: Walkways only.</li><li><code>:bike</code>: Cycleways only.</li><li><code>:all</code>: All motorways, walkways and cycleways excluding private ways.</li><li><code>:all_private</code>: All motorways, walkways and cycleways including private ways.</li><li><code>:none</code>: No network filters.</li><li><code>:rail</code>: Railways excluding proposed and platform.</li></ul><p><strong>returns</strong></p><p><code>MetaDiGraph</code> with topologically relevant nodes and edges and relevant data attached to every node and edge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/ShadowGraphs.jl/blob/5abee85382844bf0cc63d74f523b918eecb5e834/src/BuildGraph.jl#L605-L652">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ShadowGraphs.shadow_graph_from_file-Tuple{String}" href="#ShadowGraphs.shadow_graph_from_file-Tuple{String}"><code>ShadowGraphs.shadow_graph_from_file</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shadow_graph_from_file(file_path::String; network_type::Symbol=:drive)</code></pre><p>builds the shadow graph from a file containing OSM data. The file could have been downloaded with either <code>shadow_graph_from_download</code> or <code>download_osm_network</code>.</p><p><strong>arguments</strong></p><ul><li>file_path: path to file. either <code>.osm</code>, <code>.xml</code> or <code>.json</code></li><li>network_type: type of network stored in file. Options are the same as in <code>LightOSM</code>: </li></ul><p><code>:drive</code>, <code>:drive_service</code>, <code>:walk</code>, <code>:bike</code>, <code>:all</code>, <code>:all_private</code>, <code>:none</code>, <code>:rail</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/ShadowGraphs.jl/blob/5abee85382844bf0cc63d74f523b918eecb5e834/src/BuildGraph.jl#L586-L596">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ShadowGraphs.shadow_graph_from_light_osm_graph-Tuple{Any}" href="#ShadowGraphs.shadow_graph_from_light_osm_graph-Tuple{Any}"><code>ShadowGraphs.shadow_graph_from_light_osm_graph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shadow_graph_from_light_osm_graph(g)</code></pre><p>transforms a <code>LightOSM.OSMGraph</code> into a <code>MetaDiGraph</code>, containing only the topologically relevant nodes and edges. Attached to every edge and node comes a lot of data, describing this specific edge or node:</p><p><strong>nodes</strong></p><p>in the case of helper nodes:</p><ul><li><code>:lat</code></li><li><code>:lon</code></li><li><code>pointgeom</code></li><li><code>:helper=true</code></li></ul><p>in the case of non helper nodes:</p><ul><li><code>:osm_id</code></li><li><code>:lat</code></li><li><code>:lon</code></li><li><code>pointgeom</code></li><li><code>:helper=false</code></li></ul><p><strong>edges</strong></p><p>in the case of helper edges:</p><ul><li><code>:helper=true</code></li></ul><p>in the case of non helper edges:</p><ul><li>:osm_id</li><li>:tags (tags of the original osm way, with parsed <code>width</code>, <code>lanes</code>, <code>lanes:forward</code>, <code>lanes:backward</code> and <code>lanes:both_ways</code>, <code>oneway</code> and <code>reverseway</code> keys)</li><li>:edgegeom (<code>ArchGDAL linestring</code> with the geometry of the edge)</li><li>:geomlength=0</li><li>:parsing_direction (direction in which we stepped through the original way nodes to get the linestring)</li><li>:helper=false </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/ShadowGraphs.jl/blob/5abee85382844bf0cc63d74f523b918eecb5e834/src/BuildGraph.jl#L447-L478">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ShadowGraphs.shadow_graph_from_object-Tuple{Union{LightXML.XMLDocument, Dict}}" href="#ShadowGraphs.shadow_graph_from_object-Tuple{Union{LightXML.XMLDocument, Dict}}"><code>ShadowGraphs.shadow_graph_from_object</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shadow_graph_from_object(osm_data_object::Union{XMLDocument,Dict}; network_type::Symbol=:drive)</code></pre><p>builds the shadow graph from an object holding the raw OSM data. This function is using the <code>graph_from_object</code> function from <code>LightOSM</code> to first build a <code>LightOSM.OSMGraph</code> object which then gets augmented with the custom parsed ways, before it gets handed over to the <code>shadow_graph_from_light_osm_graph</code> function.</p><p><strong>arguments</strong></p><ul><li>osm<em>data</em>object</li><li>network<em>type: type of network stored in osm</em>data_object. Options are the same as in <code>LightOSM</code>: </li></ul><p><code>:drive</code>, <code>:drive_service</code>, <code>:walk</code>, <code>:bike</code>, <code>:all</code>, <code>:all_private</code>, <code>:none</code>, <code>:rail</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/ShadowGraphs.jl/blob/5abee85382844bf0cc63d74f523b918eecb5e834/src/BuildGraph.jl#L556-L567">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ShadowGraphs.width-Tuple{Any}" href="#ShadowGraphs.width-Tuple{Any}"><code>ShadowGraphs.width</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">width(tags)</code></pre><p>less opinionated version of the basic parsing <code>LightOSM</code> does, to parse the <code>width</code> tag of an osm way. Returns the parsed width if the tag exists or <code>missing</code> if not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SuperGrobi/ShadowGraphs.jl/blob/5abee85382844bf0cc63d74f523b918eecb5e834/src/BuildGraph.jl#L353-L358">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../Persistence/">IO »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Tuesday 22 November 2022 18:43">Tuesday 22 November 2022</span>. Using Julia version 1.8.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
