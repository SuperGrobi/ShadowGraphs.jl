var documenterSearchIndex = {"docs":
[{"location":"Measures/#Graph-Measures","page":"Graph Measures","title":"Graph Measures","text":"","category":"section"},{"location":"Measures/#Introduction","page":"Graph Measures","title":"Introduction","text":"","category":"section"},{"location":"Measures/","page":"Graph Measures","title":"Graph Measures","text":"We reimplement some measures for spatial graphs presented in OSMnx to work on the shadow graphs described in this package.","category":"page"},{"location":"Measures/","page":"Graph Measures","title":"Graph Measures","text":"For now, only bearing and orientation entropy are available. See Boeing, G. 2019. “Urban Spatial Order: Street Network Orientation, Configuration, and Entropy.” Applied Network Science, 4 (1), 67 for the technical details.","category":"page"},{"location":"Measures/","page":"Graph Measures","title":"Graph Measures","text":"Whenever a measurment attaches data to the graph, the tag will be prefixed with ms_, generally we do not checked if the tag exists before overwriting it. Modifying the graph will cause the measures depending on the modified part to go out of sync.","category":"page"},{"location":"Measures/#API","page":"Graph Measures","title":"API","text":"","category":"section"},{"location":"Measures/","page":"Graph Measures","title":"Graph Measures","text":"Pages = [\"Measures.md\"]","category":"page"},{"location":"Measures/","page":"Graph Measures","title":"Graph Measures","text":"Modules = [ShadowGraphs]\nPages = [\"Measures.jl\"]","category":"page"},{"location":"Measures/#ShadowGraphs.bearing_histogram-Tuple{MetaGraphs.AbstractMetaGraph}","page":"Graph Measures","title":"ShadowGraphs.bearing_histogram","text":"bearing_histogram(g::AbstractMetaGraph; weight=nothing, nbins=36, binshift=-180 / nbins, refresh_bearings=false)\n\nfits a histogram to the bearings stored in the :ms_bearing properties of edges. If refresh_bearings=true, the bearings are updated/initialised before fitting.\n\nkeyword arguments\n\nweight: name of property on the graphs edges to use as weights for the histogram. (for examle :sg_street_length. Is set to nothing, weight will be 1 for each edge.)\nnbins: number of bins for the histogram.\nbinshift: offset for bins, in degrees. (use this if your bearings end up on bin edges.)\nrefresh_bearings: if the bearings should be (re-) calculated before fitting the histogram.\n\nThe resulting bins will span from binshift to 360+binshift.\n\nreturns count histogram of bearings.\n\n\n\n\n\n","category":"method"},{"location":"Measures/#ShadowGraphs.orientation_entropy-Tuple{StatsBase.Histogram}","page":"Graph Measures","title":"ShadowGraphs.orientation_entropy","text":"orientation_entropy(hist::Histogram)\n\ncalculates the entropy of the (continuous) distribution approximated by hist according to:\n\nH=-intrholn(rho)mathrmdx approx -sumrho_iln(rho_i)Delta x_i\n\nwhere Delta x_i is the width of the i-th bin.\n\nThere is nothing inherently orientation about this function. It should just work with any general distribution you throw at it.\n\n\n\n\n\n","category":"method"},{"location":"Measures/#ShadowGraphs.orientation_order-Tuple{StatsBase.Histogram}","page":"Graph Measures","title":"ShadowGraphs.orientation_order","text":"orientation_order(hist::Histogram)\n\ncalculates the orientation order of a hist, defined as:\n\nvarphi = 1-left(fracH-H_minH_max-H_minright)^2\n\nwhere H_min is the entropy of a perfect grid and H_max is the entropy of the constant orientation distribution.\n\nThe grid entropy is only (somewhat) defined for distributions with constant bin widths, so we check if hist fulfills this condition. I am not sure if I would trust this value.\n\n\n\n\n\n","category":"method"},{"location":"Measures/#ShadowGraphs.single_bearing-Tuple{Any}","page":"Graph Measures","title":"ShadowGraphs.single_bearing","text":"single_bearing(line)\n\ncalculates the bearing of a single ArchGDAL linestring. Assumes the line is in a local coordinate system.\n\n\n\n\n\n","category":"method"},{"location":"Measures/#ShadowGraphs.tag_edge_bearings!-Tuple{MetaGraphs.AbstractMetaGraph}","page":"Graph Measures","title":"ShadowGraphs.tag_edge_bearings!","text":"tag_edge_bearings!(g::AbstractMetaGraph)\n\ncalculates the bearing of each :sg_street_geometry and attaches it to the respective edge as :ms_bearing. Helpers and self edges are ignored.\n\n\n\n\n\n","category":"method"},{"location":"Persistence/#Persistence","page":"Graph saving (and loading)","title":"Persistence","text":"","category":"section"},{"location":"Persistence/#Introduction","page":"Graph saving (and loading)","title":"Introduction","text":"","category":"section"},{"location":"Persistence/","page":"Graph saving (and loading)","title":"Graph saving (and loading)","text":"Here we collect functions responsible for saving and loading ShadowGraphs to multiple CSV files with fine control over which properties get saved. This is useful if you want to persist some state of your graph, for example after adding the shadow intervals, but you are only interested in :sg_street_length and :sg_shadow_length.","category":"page"},{"location":"Persistence/","page":"Graph saving (and loading)","title":"Graph saving (and loading)","text":"There is a very rudimentary loader returning DataFrames, which might be a good starting point to build a graph from a persisted state as outlined above.","category":"page"},{"location":"Persistence/#API","page":"Graph saving (and loading)","title":"API","text":"","category":"section"},{"location":"Persistence/","page":"Graph saving (and loading)","title":"Graph saving (and loading)","text":"Pages = [\"Persistence.md\"]","category":"page"},{"location":"Persistence/","page":"Graph saving (and loading)","title":"Graph saving (and loading)","text":"Modules = [ShadowGraphs]\nPages = [\"Persistence.jl\"]","category":"page"},{"location":"Persistence/#ShadowGraphs.export_shadow_graph_to_csv-Tuple{Any, Any}","page":"Graph saving (and loading)","title":"ShadowGraphs.export_shadow_graph_to_csv","text":"export_shadow_graph_to_csv(path, graph; edge_props=All(), vertex_props=All(), graph_props=All())\n\nsaves the shadow graph to a selection of csv files:\n\n\"path\"_nodes.csv\n\"path\"_edges.csv\n\"path\"_graph.csv (contains graph properties)\n\nAll ArchGDAL geometries are converted to WellKnownText.\n\narguments\n\npath: path to the target directory. The different specifiers are appended to the filename given in this path.\ngraph::MetaDiGraph: shadow graph to save.\n\nkeyword arguments\n\nedge_props\nvertex_props\ngraph_props\n\nare used to select which of the props on each edge, vertex and graph should be exported. Each argument takes either:\n\nDataFrames.All(): stores every property present.\nDataFrames.Not([...]): stores every porperty except for the property names passed as a vector to Not. (example: Not([:sg_helper, :sg_geometry_base]))\n[...]: only exports the properties with names in the vector. (example: [:sg_lon, :sg_lat, :sg_helper])\n\nIf an element does not have the property, an empty cell gets inserted in the csv, but only if there is at least one element with the property.\n\nreturns\n\nsaves multiple files to disk.\n\n\n\n\n\n","category":"method"},{"location":"Persistence/#ShadowGraphs.import_shadow_graph_from_csv-Tuple{Any}","page":"Graph saving (and loading)","title":"ShadowGraphs.import_shadow_graph_from_csv","text":"import_shadow_graph_from_csv(path)\n\nimports csv files saved with export_shadow_graph_to_csv. path points to the main name of the files (without suffixes). (Just plug in the same thing you plugged in to save the graph).\n\nreturns\n\nedge_df, vertex_df, graph_df: the loaded csv files as DataFrames to be further processed into whatever you need them to be.\n\n\n\n\n\n","category":"method"},{"location":"Plotting/#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"Plotting/#Introduction","page":"Plotting","title":"Introduction","text":"","category":"section"},{"location":"Plotting/","page":"Plotting","title":"Plotting","text":"We extend the functionality of (Folium.jl)[https://github.com/SuperGrobi/Folium.jl] by some convenient overloads to visualise the shadowgraph in an interactive Leaflet.js map.","category":"page"},{"location":"Plotting/#API","page":"Plotting","title":"API","text":"","category":"section"},{"location":"Plotting/","page":"Plotting","title":"Plotting","text":"Pages = [\"Plotting.md\"]","category":"page"},{"location":"Plotting/","page":"Plotting","title":"Plotting","text":"Modules = [ShadowGraphs]\nPages = [\"Plotting.jl\"]","category":"page"},{"location":"Plotting/#Folium.draw!-Union{Tuple{T}, Tuple{Folium.FoliumMap, T, AbstractVector}} where T<:MetaGraphs.AbstractMetaGraph","page":"Plotting","title":"Folium.draw!","text":"draw!(fig::FoliumMap, g::T, path::AbstractVector; kwargs...) where {T<:AbstractMetaGraph}\n\ndraws the path given by node ids in g into fig. Uses the :sg_geometry-field of the nodes and the :sg_street_geometry field of the edges. kwargs are applied to both, cirles and lines. Does some fancy stuff to connect the lines when possible.\n\nreturns fig (passthrough)\n\n\n\n\n\n","category":"method"},{"location":"Plotting/#Folium.draw!-Union{Tuple{T}, Tuple{Folium.FoliumMap, T, Symbol}} where T<:MetaGraphs.AbstractMetaGraph","page":"Plotting","title":"Folium.draw!","text":"draw!(fig::FoliumMap, g::T, series_type::Symbol; kwargs...) where {T<:AbstractMetaGraph}\n\ndraws the given data series properies of the graph into a Folium.jl map.\n\narguments\n\nfig::FoliumMap: map to draw in. (You can leave this argument out and let the folium callstack figure things out.)\ng: shadow graph carying the data.\nseries_type: type of data to draw from the graph. Pick from: :vertices, :edges, :streets, :shadows or any edge property containing data we can draw with folium.\n\nkeyword arguments\n\ndraw_arrow: if there should be a circle drawn 80% along the geometry. (only applies when series_type is :streets)\nkwargs: keywords passed to folium for every element of series_type. (see the python docs and the leaflet docs for a full list of all options.)\n\nEvery series_type has a few sensible defaults set, most importantly the default tooltips and popups, which, by default show some interesting data about the vertices and edges, respectively.\n\nCurrently, the kwargs are set for every element, there is (currently) no way to set individual parameters for each element.\n\nreturns\n\nfig::FoliumMap (passthrough of argument)\n\n\n\n\n\n","category":"method"},{"location":"BuildGraph/#Building-Graphs","page":"Graph creation","title":"Building Graphs","text":"","category":"section"},{"location":"BuildGraph/#Introduction","page":"Graph creation","title":"Introduction","text":"","category":"section"},{"location":"BuildGraph/","page":"Graph creation","title":"Graph creation","text":"We use LightOSM.jl as a basis to handle all the downloading, saving and importing of OSM data. We provide functions for (down)loading graphs which should feel very similar to any user of LightOSM.","category":"page"},{"location":"BuildGraph/","page":"Graph creation","title":"Graph creation","text":"The LightOSM.OSMGraph instance is parsed and simplified into a MetaDiGraph, preserving the topology of the original street network, while reducing the number of nodes as much as possible. The geometry and various other parameters are attached to the props of every edge and vertex.","category":"page"},{"location":"BuildGraph/","page":"Graph creation","title":"Graph creation","text":"One noteable difference to the LightOSM graphs is that we take special care to not assume anything about the dataset from OSM. Therefore, whenever there is no information available about a certain tag, we parse it as missing, rather than setting a default value.","category":"page"},{"location":"BuildGraph/","page":"Graph creation","title":"Graph creation","text":"(Image: Process of graph simplification)","category":"page"},{"location":"BuildGraph/#API","page":"Graph creation","title":"API","text":"","category":"section"},{"location":"BuildGraph/","page":"Graph creation","title":"Graph creation","text":"Pages = [\"BuildGraph.md\"]","category":"page"},{"location":"BuildGraph/","page":"Graph creation","title":"Graph creation","text":"CurrentModule = ShadowGraphs","category":"page"},{"location":"BuildGraph/#Exposed-functions","page":"Graph creation","title":"Exposed functions","text":"","category":"section"},{"location":"BuildGraph/","page":"Graph creation","title":"Graph creation","text":"shadow_graph_from_file\nshadow_graph_from_download","category":"page"},{"location":"BuildGraph/#ShadowGraphs.shadow_graph_from_file","page":"Graph creation","title":"ShadowGraphs.shadow_graph_from_file","text":"shadow_graph_from_file(file_path::String; network_type::Symbol=:drive, timezone=tz\"Europe/London\")\n\nbuilds the shadow graph from a file containing OSM data. The file could have been downloaded with either shadow_graph_from_download or LightOSM.download_osm_network.\n\narguments\n\nfile_path: path to file. either .osm, .xml or .json\nnetwork_type: type of network stored in file. Options are the same as in LightOSM: \n\n:drive, :drive_service, :walk, :bike, :all, :all_private, :none, :rail\n\n\n\n\n\n","category":"function"},{"location":"BuildGraph/#ShadowGraphs.shadow_graph_from_download","page":"Graph creation","title":"ShadowGraphs.shadow_graph_from_download","text":"function shadow_graph_from_download(download_method::Symbol;\n                                    timezone=tz\"Europe/London\",\n                                    network_type::Symbol=:drive,\n                                    metadata::Bool=false,\n                                    download_format::Symbol=:json,\n                                    save_to_file_location::Union{String,Nothing}=nothing,\n                                    download_kwargs...)\n\ndownloads and builds the shadow graph from OSM.\n\narguments\n\ndownload_method::Symbol: Download method, choose from :place_name, :bbox, :point, :polygon and (added by this package) :extent.\ntimezone: Timezone the streets are in.\nnetwork_type::Symbol=:drive: Network type filter, pick from :drive, :drive_service, :walk, :bike, :all, :all_private, :none, :rail\nmetadata::Bool=false: Set true to return metadata.\ndownload_format::Symbol=:json: Download format, either :osm, :xml or json.\nsave_to_file_location::Union{String,Nothing}=nothing: Specify a file location to save downloaded data to disk.\n\nRequired Kwargs for each Download Method\n\ndownload_method=:place_name\n\nplace_name::String: Any place name string used as a search argument to the Nominatim API.\n\ndownload_method=:bbox\n\nminlat::AbstractFloat: Bottom left bounding box latitude coordinate.\nminlon::AbstractFloat: Bottom left bounding box longitude coordinate.\nmaxlat::AbstractFloat: Top right bounding box latitude coordinate.\nmaxlon::AbstractFloat: Top right bounding box longitude coordinate.\n\ndownload_method=:point\n\npoint::GeoLocation: Centroid point to draw the bounding box around.\nradius::Number: Distance (km) from centroid point to each bounding box corner.\n\ndownload_method=:polygon\n\npolygon::AbstractVector: Vector of longitude-latitude pairs.\n\ndownload_method=:extent\n\nextent::Extents.Extent: Extent holding the bounding box for the download. Follows the GeoInterface convention (for example extent=Extent(X=(minlon, maxlon), Y=(minlat, maxlat)))\n\nNetwork Types\n\n:drive: Motorways excluding private and service ways.\n:drive_service: Motorways including private and service ways.\n:walk: Walkways only.\n:bike: Cycleways only.\n:all: All motorways, walkways and cycleways excluding private ways.\n:all_private: All motorways, walkways and cycleways including private ways.\n:none: No network filters.\n:rail: Railways excluding proposed and platform.\n\nreturns\n\nMetaDiGraph with topologically relevant nodes and edges and relevant data attached to every node and edge.\n\n\n\n\n\n","category":"function"},{"location":"BuildGraph/#Internals","page":"Graph creation","title":"Internals","text":"","category":"section"},{"location":"BuildGraph/","page":"Graph creation","title":"Graph creation","text":"shadow_graph_from_object\nshadow_graph_from_light_osm_graph\nadd_edge_with_data!\ngeolinestring\nget_all_node_lists\ndecompose_way_to_primitives\nget_rotational_direction\ncountall\nadd_this_node\nis_circular_way\nis_end_node\nparse_raw_ways\nparse_lanes\nwidth","category":"page"},{"location":"BuildGraph/#ShadowGraphs.shadow_graph_from_object","page":"Graph creation","title":"ShadowGraphs.shadow_graph_from_object","text":"shadow_graph_from_object(osm_data_object::Union{XMLDocument,Dict}; network_type::Symbol=:drive, timezone)\n\nbuilds the shadow graph from an object holding the raw OSM data. This function is using the graph_from_object function from LightOSM to first build a LightOSM.OSMGraph object which, due to the opinionated parsing of tags in LightOSM holds some made up values in the ways field for non-existing tags.\n\nIn this function, we replace these opinionated values with the ways we get from ShadowGraphs.parse_raw_ways. The main difference compared to LightOSM is, that we set every tag we expect from a street, but not get to missing, instead of assuming some value.\n\nThe in this way augmented graph gets then handed over to shadow_graph_from_light_osm_graph.\n\narguments\n\nosmdataobject\nnetworktype: type of network stored in osmdata_object. Options are the same as in LightOSM: \n\n:drive, :drive_service, :walk, :bike, :all, :all_private, :none, :rail\n\ntimezone: timezone the streets are in.\n\n\n\n\n\n","category":"function"},{"location":"BuildGraph/#ShadowGraphs.shadow_graph_from_light_osm_graph","page":"Graph creation","title":"ShadowGraphs.shadow_graph_from_light_osm_graph","text":"shadow_graph_from_light_osm_graph(g; timezone)\n\ntransforms a LightOSM.OSMGraph into a MetaDiGraph, containing only the topologically relevant nodes and edges. Attached to every edge and node comes a lot of data, needed for future processing of the graph, preserving all information coming from open street maps (I think we throw away the node tags).\n\nThe returned MetaDiGraph conforms to the requirements to be considered a shadow graph and used within the MinistryOfCoolWalks ecosystem.\n\nAll props prefixed with sg_ are handled by functions within the MinistryOfCoolWalks ecosystem and should be considered read-only. Changing them directly might lead to unexpected behaviour.\n\ntimezone is used to set the tz field of the ShadowObservatory.\n\nAlways clone geometries with ArchGDAL.clone if you want to use them separate of the graph. (Check your references!)\n\n\n\n\n\n","category":"function"},{"location":"BuildGraph/#ShadowGraphs.add_edge_with_data!","page":"Graph creation","title":"ShadowGraphs.add_edge_with_data!","text":"add_edge_with_data!(g, s, d; data=Dict())\n\nadds new edge from s to d to g::MetaDiGraph, and populates it with the props given in data.\n\ndata is expected to have at least a key :sg_street_geometry, containing the geometry of the street between s and d as an ArchGDAL linestring in the WSG84 system. (Use CoolWalksUtils.apply_wsg_84!)\n\nSpecial care is given to self and multi edges:\n\nself edges: if s==d, two new vertices are added at 10% and 60% along the :sg_street_geometry, with props of :sg_lat, :sg_lon, sg_geometry and :sg_helper=true set acordingly.\n\nThese new vertices (h1 and h2) are then connected to form a loop like: s --helper_edge1--> h1 --real_edge--> h2 --helper_edge2--> d, where helper_edge1 and helper_edge2 are helper edges with only one prop of :sg_helper=true. real_edge is carrying all the props defined in data.\n\nmulti edges: if Edge(s,d) ∈ Edges(g), we add one new helper vertex at 50% along the :sg_street_geometry with props of :sg_lat, :sg_lon, sg_geometry and :sg_helper=true.\n\nWe connect to the graph like this: s --helper_edge--> h --real_edge--> d, where helper_edge is a helper edge with only one prop, :sg_helper=true. real_edge carries all the props specified in data.\n\nThis process is nessecary to preserve the street network topology, since MetaDiGraphs do not support multi edges (and therefore also no multi self edges).\n\n\n\n\n\n","category":"function"},{"location":"BuildGraph/#ShadowGraphs.geolinestring","page":"Graph creation","title":"ShadowGraphs.geolinestring","text":"geolinestring(nodes, node_id_list)\n\ncreates an ArchGDAL linestring from a dictionary mapping osm node ids to LightOSM.Node and a list of osm node ids, representing the nodes of the linestring in order.\n\n\n\n\n\n","category":"function"},{"location":"BuildGraph/#ShadowGraphs.get_all_node_lists","page":"Graph creation","title":"ShadowGraphs.get_all_node_lists","text":"get_all_node_lists(primitive_way, topological_osm_ids)\n\nget vector of vectors where each element contains the osm_ids between two topologically relevant nodes, in the same order as they occur in primitive way. Takes care of cyclical ways.\n\nOnly use on primitive ways.\n\n\n\n\n\n","category":"function"},{"location":"BuildGraph/#ShadowGraphs.decompose_way_to_primitives","page":"Graph creation","title":"ShadowGraphs.decompose_way_to_primitives","text":"decompose_way_to_primitives(way::Way)\n\nDecomposed a way with possible self-intersections/loops into multiple ways which are guaranteed to be either\n\nnon-intersecting lines, where every node in the way is unique, or\ncircular ways, where only the first and last node in the way are not unique.\n\nexample\n\na way with nodes [10,20,30,40,50,30] (which looks like a triangle on a stick, note the repeated 30) will be decomposed into two ways, with the nodes [10,20,30] and [30,40,50,30].\n\n\n\n\n\n","category":"function"},{"location":"BuildGraph/#ShadowGraphs.get_rotational_direction","page":"Graph creation","title":"ShadowGraphs.get_rotational_direction","text":"get_rotational_direction(way::Way, nodes, direction)\n\ncalculates the direction of rotation of the way if walked through in the direction of direction (either 1 or -1). Since the node locations are stored seperately, you have to pass in a dict node_id=>LightOSM.Node into nodes. Used only on simplified ways.\n\nReturns\n\n1 if the rotation is righthanded\n-1 if the rotation is lefthanded\n0 if the way is not closed\n\n\n\n\n\n","category":"function"},{"location":"BuildGraph/#ShadowGraphs.countall","page":"Graph creation","title":"ShadowGraphs.countall","text":"countall(numbers)\n\ncounts how often every number appears in numbers. Returns dict with number=>count\n\n\n\n\n\n","category":"function"},{"location":"BuildGraph/#ShadowGraphs.add_this_node","page":"Graph creation","title":"ShadowGraphs.add_this_node","text":"add_this_node(g, osm_id)\n\nchecks if the node with osm_id in graph g should be added to the shadow graph. Currently, we add a node if one of the following is true:\n\nif the number of ways the node is part of is larger than 1\nif the node is the end of a street, that is, if it has only one neighbour in g\nif the node occurs more than once in the way it is part of, excluding the end point, if the way is circular\n\n\n\n\n\n","category":"function"},{"location":"BuildGraph/#ShadowGraphs.is_circular_way","page":"Graph creation","title":"ShadowGraphs.is_circular_way","text":"is_circular_way(way::Way)\n\nchecks if a LightOSM.Way way starts at the same node it ends.\n\n\n\n\n\n","category":"function"},{"location":"BuildGraph/#ShadowGraphs.is_end_node","page":"Graph creation","title":"ShadowGraphs.is_end_node","text":"is_end_node(g, index)\n\nchecks if node index in graph g represents the end of a street (that is, has as most one neighbour).\n\n\n\n\n\n","category":"function"},{"location":"BuildGraph/#ShadowGraphs.parse_raw_ways","page":"Graph creation","title":"ShadowGraphs.parse_raw_ways","text":"parse_raw_ways(raw_ways, network_type)\n\nparses a list of dicts describing OSM Ways into LightOSM.Way instances. This function is a slightly modified version of the one used in LightOSM (parse_osm_network_dict), to be able to use our own, non-dafault value assuming parsers for the labels.\n\nreturns\n\na dictionary mapping osm_id to LightOSM.Way\n\n\n\n\n\n","category":"function"},{"location":"BuildGraph/#ShadowGraphs.parse_lanes","page":"Graph creation","title":"ShadowGraphs.parse_lanes","text":"parse_lanes(tags::AbstractDict, tagname)\n\nparses the value of the key tagname in tags, assuming it to be a numerical value describing a certain number of lanes. Returns the parsed number of lanes if the tag exists or missing if not.\n\n\n\n\n\n","category":"function"},{"location":"BuildGraph/#ShadowGraphs.width","page":"Graph creation","title":"ShadowGraphs.width","text":"width(tags)\n\nless opinionated version of the basic parsing LightOSM does, to parse the width tag of an osm way. Returns the parsed width if the tag exists or missing if not. If values are negative, we take the absolute value.\n\n\n\n\n\n","category":"function"},{"location":"Pedestrianization/#Pedestrianization","page":"Pedestrianization","title":"Pedestrianization","text":"","category":"section"},{"location":"Pedestrianization/#Introduction","page":"Pedestrianization","title":"Introduction","text":"","category":"section"},{"location":"Pedestrianization/","page":"Pedestrianization","title":"Pedestrianization","text":"Our shadow graphs are generally directed to allow for one-way streets. However, in the context of pedestrian routing, we might want to ignore this directedness. When pedestrianizing a graph, we add the reverse edge for every edge if it does not yet exist, together with the correctly inverted data like geometry and parsing direction.","category":"page"},{"location":"Pedestrianization/","page":"Pedestrianization","title":"Pedestrianization","text":"Apply before centerline correction, as the revese edge should be offset in the other direction.","category":"page"},{"location":"Pedestrianization/#API","page":"Pedestrianization","title":"API","text":"","category":"section"},{"location":"Pedestrianization/","page":"Pedestrianization","title":"Pedestrianization","text":"Pages = [\"Pedestrianization.md\"]","category":"page"},{"location":"Pedestrianization/","page":"Pedestrianization","title":"Pedestrianization","text":"Modules = [ShadowGraphs]\nPages = [\"Pedestrianization.jl\"]","category":"page"},{"location":"Pedestrianization/#ShadowGraphs.pedestrianize!-Tuple{MetaGraphs.MetaDiGraph}","page":"Pedestrianization","title":"ShadowGraphs.pedestrianize!","text":"pedestrianize!(g::MetaDiGraph)\n\nfor every edge in g which has not a reverse edge, adds a reverse edge with reversed geometry (:sg_geometry_base and sg_street_geometry) and parsing direction :sg_parsing_direction * -1 of the original one. For :sg_helper edges, adds only a key :sg_helper=true to the new reverse edge.\n\nApply before centerline correction, as the new reverse geometry will be corrected in the other direction.\n\n\n\n\n\n","category":"method"},{"location":"Pedestrianization/#ShadowGraphs.reverse_geometry-Tuple{Any}","page":"Pedestrianization","title":"ShadowGraphs.reverse_geometry","text":"reverse_geometry(geom)\n\nreturns a copy of the input linestring with the same spatialref but reversed order of points.\n\n\n\n\n\n","category":"method"},{"location":"Projection/#Projecting-Shadow-Graphs","page":"Projection","title":"Projecting Shadow Graphs","text":"","category":"section"},{"location":"Projection/#Introduction","page":"Projection","title":"Introduction","text":"","category":"section"},{"location":"Projection/","page":"Projection","title":"Projection","text":"We add methods to project_local! and project_back! from CoolWalksUtils.jl which allow for simpler projection of shadow graphs. Whithin them, the ArchGDAL geometry attached to nodes and edges are projected into a transverse mercator projection, and back.","category":"page"},{"location":"Projection/#API","page":"Projection","title":"API","text":"","category":"section"},{"location":"Projection/","page":"Projection","title":"Projection","text":"Pages = [\"Projection.md\"]","category":"page"},{"location":"Projection/","page":"Projection","title":"Projection","text":"Modules = [ShadowGraphs]\nPages = [\"Projection.jl\"]","category":"page"},{"location":"Projection/#CoolWalksUtils.project_back!-Tuple{T} where T<:MetaGraphs.AbstractMetaGraph","page":"Projection","title":"CoolWalksUtils.project_back!","text":"project_back!(g::T) where {T<:AbstractMetaGraph}\n\nprojects all ArchGDAL geometry in the props of edges and nodes of g back to EPSG4236 and updates the :sg_crs property of g accordingly. Returns g.\n\n\n\n\n\n","category":"method"},{"location":"Projection/#CoolWalksUtils.project_local!-Union{Tuple{T}, Tuple{T, CoolWalksUtils.ShadowObservatory}} where T<:MetaGraphs.AbstractMetaGraph","page":"Projection","title":"CoolWalksUtils.project_local!","text":"project_local!(g::T, obs::ShadowObservatory=get_prop(g, :sg_observatory)) where {T<:AbstractMetaGraph}\nproject_local!(g::T, lon, lat) where {T<:AbstractMetaGraph}\n\nprojects all ArchGDAL geometry in the props of edges and nodes of g to transverse mercator, centered around the obs (or lon, lat) and updates the :sg_crs property of g accordingly. All geometry is assumed to be in the :sg_crs system. Returns the projected g.\n\n\n\n\n\n","category":"method"},{"location":"Projection/#ShadowGraphs._execute_edge_projection!-Tuple{Any, Any}","page":"Projection","title":"ShadowGraphs._execute_edge_projection!","text":"_execute_edge_projection!(g, trans)\n\napplies the ArchGDAL transformation trans to every ArchGDAL geometry in the props of the edges of g.\n\n\n\n\n\n","category":"method"},{"location":"Projection/#ShadowGraphs._execute_node_projection!-Tuple{Any, Any}","page":"Projection","title":"ShadowGraphs._execute_node_projection!","text":"_execute_node_projection!(g, trans)\n\napplies the ArchGDAL transformation trans to every ArchGDAL geometry in the props of the nodes of g.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ShadowGraphs","category":"page"},{"location":"#ShadowGraphs","page":"Home","title":"ShadowGraphs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for ShadowGraphs.","category":"page"},{"location":"#Interface","page":"Home","title":"Interface","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To be usable in the MinistryOfCoolWalks ecosystem, the shadowgraph::MetaDiGraph needs to fulfill a set of requirements detailed below. To check if a graph fulfills the technical requirements use ShadowGraphs.check_shadow_graph_integrity","category":"page"},{"location":"","page":"Home","title":"Home","text":"In general, all props handled by the MinistryOfCoolWalks ecosystem start with sg_. They are considered to be read-only. Setting them directly might lead to unexpected behaviour.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The weightfield of the graph should be set to :sg_street_length, the defaultweight should be 0.0.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Remember to ArchGDAL.clone geometries if you want to use them independently of the graph, otherwise you might observe strange behaviour when mutating the graph (as you will only get a reference to the geometry from get_prop(...)).","category":"page"},{"location":"#graph-level","page":"Home","title":"graph level","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":":sg_crs: Coordinate system the graph is currently in. (Uses ArchGDAL coordinate systems.)\n:sg_offset_dir: Direction in which the streets should be offset (Should be +1 for right hand side driving and -1 for left hand side driving.)\n:sg_observatory: CoolWalksUtils.ShadowObservatory holding the center of the graph, for projection purposes. (Note that the timezone in the tz field is not used.)","category":"page"},{"location":"#nodes","page":"Home","title":"nodes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":":sg_osm_id: id of the original node in the OSM database. (set this to anything you want for helper nodes.)\n:sg_lat: latitude of the original node in the OSM database.\n:sg_lon: longitude of the original node in the OSM database.\nsg_geometry: ArchGDAL point containing representing the node.\n:sg_helper: if this node is a helper node.","category":"page"},{"location":"#edges","page":"Home","title":"edges","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Edges have different properties depending on whether they are helper edges (:sg_helper) or not.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If they are helpers, they only have :sg_helper=true.","category":"page"},{"location":"","page":"Home","title":"Home","text":"otherwise, the available properties are:","category":"page"},{"location":"","page":"Home","title":"Home","text":":sg_osm_id: id of the original way in the OSM database.\n:sg_tags: tags of the original OSM way. (See ShadowGraphs.parse_raw_ways for more information on the content and guarantees.)\n:sg_geometry_base: ArchGDAL linestring with the geometry of the edge. (Used as baseline to reset the graph.)\n:sg_street_geometry: final geometry of the street. (originally a copy of :sg_geometry_base, will be modified during offsetting.)\n:sg_street_length: length of sg_street_geometry in a projected coordinate system.\n:sg_parsing_direction: Direction in which we stepped through the original way to get the geometry. (Needed to figure out in which direction the geometry needs to be offset.)\n:sg_helper=false: if this edge is a helper edge (always false if the above props exist.)","category":"page"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"index.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [ShadowGraphs]\nPages = [\"ShadowGraphs.jl\"]","category":"page"},{"location":"#ShadowGraphs.check_shadow_graph_integrity-Tuple{Any}","page":"Home","title":"ShadowGraphs.check_shadow_graph_integrity","text":"check_shadow_graph_integrity(g; strict=false)\n\nchecks if all the properties needed to be a shadow graph are present in g. See the documentation for an overview.\n\nIf strict=true, we check if there are only the needed props present. Use this to test a non-mutated graph (for example directly after construction, before adding shadows).\n\n\n\n\n\n","category":"method"},{"location":"RTreeBuilding/#Building-R-Trees-from-Graphs","page":"RTree Building","title":"Building R-Trees from Graphs","text":"","category":"section"},{"location":"RTreeBuilding/#Introduction","page":"RTree Building","title":"Introduction","text":"","category":"section"},{"location":"RTreeBuilding/","page":"RTree Building","title":"RTree Building","text":"We add a method to build_rtree from CoolWalksUtils.jl which allows to build an R-Tree from a Shadow Graph.","category":"page"},{"location":"RTreeBuilding/#API","page":"RTree Building","title":"API","text":"","category":"section"},{"location":"RTreeBuilding/","page":"RTree Building","title":"RTree Building","text":"Pages = [\"RTreeBuilding.md\"]","category":"page"},{"location":"RTreeBuilding/","page":"RTree Building","title":"RTree Building","text":"Modules = [ShadowGraphs]\nPages = [\"RTreeBuilding.jl\"]","category":"page"},{"location":"RTreeBuilding/#CoolWalksUtils.build_rtree-Tuple{MetaGraphs.AbstractMetaGraph}","page":"RTree Building","title":"CoolWalksUtils.build_rtree","text":"CoolWalksUtils.build_rtree(g::AbstractMetaGraph)\n\nbuilds SpatialIndexing.RTree{Float64, 2} from an AbstractMetaGraph containing vertices with at least a :sg_geometry prop and edges with a :sg_street_geometry prop. (edges and vertices without this prop are skipped, but do not throw an error.) The extent of each node is based on these properties.\n\nThe id of each entry in the tree is of type Edge and represents the edge the values are derived from. If the entry is a vertex v, the id will be an Edge(v,v). (See also the val.type entry on how to distiguish between edges and nodes.)\n\nThe value of an entry in the RTree is a named tuple with: (orig=original_geometry, prep=prepared_geometry, type=graph_geom_type, data=props_of_edge_or_vertex). where orig is the original geometry stored in props[:sg_geometry] or props[:sg_street_geometry], and prep is the prepared geometry, derived from orig. It can be used in a few ArchGDAL functions to get higher performance, for example in intersection testing, because relevant values get precomputed and cashed in the prepared geometry, rather than recomputed on every test.\n\nNote that only the first element in these tests can be a prepared geometry, for example ArchGDAL.intersects(normal_geom, prepared_geom) is a highway to segfault-town, while ArchGDAL.intersects(prepared_geom, normal_geom) is fine and great.\n\nThe type entry is either :edge or :vertex, to help distinguish between entries for edges and vertices.\n\nThe data entry contains the Dictionary returned by props(g, i) where i is either a vertex or an edge. This gives access to all relevant properties of the graph.\n\n\n\n\n\n","category":"method"}]
}
